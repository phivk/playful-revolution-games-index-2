---
phase: 04-deployment
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - api/oauth/authorize.ts
  - api/auth/callback.ts
  - public/admin/config.yml
autonomous: true
requirements: [DEPL-02]

must_haves:
  truths:
    - "A Vercel serverless function exists at `/api/oauth/authorize` that redirects users to GitHub OAuth login"
    - "A Vercel serverless function exists at `/api/auth/callback` that exchanges the GitHub code for an access token and returns it to Decap CMS"
    - "Decap CMS `config.yml` points to the custom OAuth endpoints so the Login button triggers GitHub OAuth"
  artifacts:
    - path: "api/oauth/authorize.ts"
      provides: "GitHub OAuth authorize redirect endpoint"
      exports: ["default"]
    - path: "api/auth/callback.ts"
      provides: "GitHub OAuth token exchange endpoint"
      exports: ["default"]
    - path: "public/admin/config.yml"
      provides: "Decap CMS backend config with custom OAuth endpoints"
      contains: "auth_endpoint"
  key_links:
    - from: "public/admin/config.yml"
      to: "api/oauth/authorize.ts"
      via: "auth_endpoint config field"
      pattern: "auth_endpoint.*api/oauth/authorize"
    - from: "public/admin/config.yml"
      to: "api/auth/callback.ts"
      via: "token_endpoint config field"
      pattern: "token_endpoint.*api/auth/callback"
    - from: "api/auth/callback.ts"
      to: "github.com/login/oauth/access_token"
      via: "fetch POST with client_id + client_secret + code"
      pattern: "github\\.com/login/oauth/access_token"
---

<objective>
Implement GitHub OAuth serverless functions for Decap CMS and update CMS config to use them.

Purpose: Decap CMS requires server-side OAuth token exchange (the CLIENT_SECRET must never be on the client). Vercel serverless functions at the project root `api/` directory provide this without conflicting with Next.js's `output: 'export'` static build — the `/api/*` routes are served by Vercel's platform layer, not included in the static `/out` export.

Output: `api/oauth/authorize.ts`, `api/auth/callback.ts`, updated `public/admin/config.yml`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-deployment/04-CONTEXT.md
@.planning/phases/04-deployment/04-RESEARCH.md
@public/admin/config.yml
@next.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub OAuth serverless functions</name>
  <files>api/oauth/authorize.ts, api/auth/callback.ts</files>
  <action>
    Create Vercel serverless functions at the project ROOT `api/` directory (NOT in `src/app/api/`). Placing them in the root `api/` directory means Vercel treats them as standalone serverless functions, independent of Next.js's static export. Next.js with `output: 'export'` does NOT process these files — Vercel's platform does.

    Create `api/oauth/authorize.ts`:

    ```typescript
    import type { VercelRequest, VercelResponse } from '@vercel/node';

    export default function handler(req: VercelRequest, res: VercelResponse) {
      const clientId = process.env.GITHUB_CLIENT_ID;

      if (!clientId) {
        res.status(500).json({ error: 'GITHUB_CLIENT_ID environment variable is not set' });
        return;
      }

      // Determine the redirect URI based on the request host
      const proto = req.headers['x-forwarded-proto'] || 'https';
      const host = req.headers['x-forwarded-host'] || req.headers.host;
      const redirectUri = `${proto}://${host}/api/auth/callback`;

      // Simple random state for basic CSRF protection
      const state = Math.random().toString(36).substring(2, 15);

      const authorizeUrl = new URL('https://github.com/login/oauth/authorize');
      authorizeUrl.searchParams.append('client_id', clientId);
      authorizeUrl.searchParams.append('redirect_uri', redirectUri);
      authorizeUrl.searchParams.append('scope', 'repo user:email');
      authorizeUrl.searchParams.append('state', state);

      res.redirect(302, authorizeUrl.toString());
    }
    ```

    Create `api/auth/callback.ts`:

    ```typescript
    import type { VercelRequest, VercelResponse } from '@vercel/node';

    export default async function handler(req: VercelRequest, res: VercelResponse) {
      const { code, error } = req.query;

      if (error) {
        // GitHub returned an error (e.g. user denied access)
        res.status(400).send(
          `<script>
            window.opener.postMessage(
              'authorization:github:error:${String(error)}',
              window.location.origin
            );
            window.close();
          </script>`
        );
        return;
      }

      if (!code || typeof code !== 'string') {
        res.status(400).json({ error: 'No authorization code provided' });
        return;
      }

      const clientId = process.env.GITHUB_CLIENT_ID;
      const clientSecret = process.env.GITHUB_CLIENT_SECRET;

      if (!clientId || !clientSecret) {
        res.status(500).json({ error: 'OAuth credentials not configured' });
        return;
      }

      try {
        const tokenResponse = await fetch('https://github.com/login/oauth/access_token', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
          },
          body: JSON.stringify({
            client_id: clientId,
            client_secret: clientSecret,
            code,
          }),
        });

        const data = await tokenResponse.json() as { access_token?: string; token_type?: string; error?: string };

        if (data.error || !data.access_token) {
          res.status(400).send(
            `<script>
              window.opener.postMessage(
                'authorization:github:error:${data.error || 'token_exchange_failed'}',
                window.location.origin
              );
              window.close();
            </script>`
          );
          return;
        }

        // Decap CMS expects a postMessage with the token in this exact format
        const token = data.access_token;
        const tokenType = data.token_type || 'bearer';

        res.setHeader('Content-Type', 'text/html');
        res.send(
          `<!DOCTYPE html>
          <html>
          <body>
          <script>
            (function() {
              function receiveMessage(e) {
                window.opener.postMessage(
                  'authorization:github:success:{"token":"${token}","provider":"github"}',
                  e.origin
                );
              }
              window.addEventListener("message", receiveMessage, false);
              window.opener.postMessage("authorizing:github", "*");
            })();
          </script>
          </body>
          </html>`
        );
      } catch (err) {
        res.status(500).json({ error: 'Token exchange request failed' });
      }
    }
    ```

    Install the `@vercel/node` type definitions (dev dependency only — no runtime cost):

    ```bash
    npm install --save-dev @vercel/node
    ```

    This gives type safety for `VercelRequest` and `VercelResponse` without adding runtime dependencies.
  </action>
  <verify>
    1. `ls api/oauth/authorize.ts api/auth/callback.ts` — both files exist
    2. `npx tsc --noEmit api/oauth/authorize.ts 2>&1` — no type errors (or run `npx tsc --noEmit` project-wide)
    3. `cat api/oauth/authorize.ts` — contains `GITHUB_CLIENT_ID`, `github.com/login/oauth/authorize`, `scope`, `state`
    4. `cat api/auth/callback.ts` — contains `GITHUB_CLIENT_SECRET`, `github.com/login/oauth/access_token`, `postMessage`, `authorization:github:success`
    5. `npm run build` still passes (API routes in root `/api/` are ignored by Next.js static export)
  </verify>
  <done>
    - `api/oauth/authorize.ts` exists and redirects to GitHub OAuth with correct client_id, redirect_uri, scope, and state
    - `api/auth/callback.ts` exists and exchanges OAuth code for token using GITHUB_CLIENT_SECRET (from env var), returns postMessage response that Decap CMS understands
    - `@vercel/node` installed as dev dependency
    - `npm run build` still succeeds (no conflict with static export)
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Decap CMS config to use custom OAuth endpoints</name>
  <files>public/admin/config.yml</files>
  <action>
    Update `public/admin/config.yml` to replace the bare `git-gateway` backend config with one that specifies the custom OAuth endpoints. The current config is:

    ```yaml
    backend:
      name: git-gateway
      branch: main
    ```

    Replace the backend block with:

    ```yaml
    backend:
      name: github
      repo: YOUR-GITHUB-USERNAME/playful-revolution-games-index-2
      branch: main
      base_url: /
      auth_endpoint: api/oauth/authorize
    ```

    IMPORTANT: Use `name: github` (not `git-gateway`) when using a custom OAuth handler. The `git-gateway` backend expects Netlify Identity to handle auth. With a custom OAuth handler on Vercel, the correct backend is `name: github` which connects directly to GitHub. This is well-documented in Decap CMS docs.

    The `repo` field must match the actual GitHub repository (e.g., `phivk/playful-revolution-games-index-2`). Use a placeholder `YOUR-GITHUB-USERNAME/playful-revolution-games-index-2` that the user must update with their actual GitHub username before first deploy.

    Add a comment at the top of the file explaining what must be changed before going live.

    The final `config.yml` should look like:

    ```yaml
    # IMPORTANT: Before deploying, replace YOUR-GITHUB-USERNAME below with your actual GitHub username.
    # The repo field must match your GitHub repository (e.g., phivk/playful-revolution-games-index-2).
    backend:
      name: github
      repo: YOUR-GITHUB-USERNAME/playful-revolution-games-index-2
      branch: main
      base_url: /
      auth_endpoint: api/oauth/authorize

    media_folder: "public/images"
    public_folder: "/images"

    collections:
      - name: "games"
        label: "Games"
        folder: "content/games"
        create: true
        delete: true
        slug: "{{slug}}"
        fields:
          - { label: "ID", name: "id", widget: "uuid" }
          - { label: "Slug", name: "slug", widget: "string" }
          - { label: "Title", name: "title", widget: "string" }
          - { label: "Description", name: "description", widget: "text" }
          - label: "Tags"
            name: "tags"
            widget: "list"
            field:
              { label: "Tag", name: "tag", widget: "select", options: ["Social Spontaneity", "Group Circle Games", "Collaborative", "Competitive", "Ball Games", "Theatre Sports", "Movement", "Table Games"] }
          - label: "Pillars"
            name: "pillars"
            widget: "select"
            multiple: true
            options: ["Intellectual", "Social", "Physical"]
          - { label: "Energy Level", name: "energyLevel", widget: "select", options: ["Low", "Medium", "High"] }
          - { label: "Materials", name: "materials", widget: "list", field: { label: "Material", name: "material", widget: "string" } }
          - { label: "Setup", name: "setup", widget: "text" }
          - { label: "How to Play", name: "howToPlay", widget: "list", field: { label: "Step", name: "step", widget: "text" } }
    ```
  </action>
  <verify>
    1. `cat public/admin/config.yml` shows `name: github` (not `git-gateway`)
    2. `cat public/admin/config.yml` shows `auth_endpoint: api/oauth/authorize`
    3. `cat public/admin/config.yml` shows the comment about replacing YOUR-GITHUB-USERNAME
    4. All original collections fields are preserved (games collection with all field definitions intact)
    5. `npm run build` still succeeds (config.yml is a static asset, no impact on build)
  </verify>
  <done>
    - `public/admin/config.yml` uses `backend: name: github` with `auth_endpoint: api/oauth/authorize`
    - CMS collection fields are preserved from the original config
    - Comment at top of file instructs user to update the `repo` field with their actual GitHub username before deploying
  </done>
</task>

</tasks>

<verification>
1. Both OAuth handler files exist: `api/oauth/authorize.ts` and `api/auth/callback.ts`
2. `npm run build` still succeeds after adding root-level API files
3. `public/admin/config.yml` has `name: github` and `auth_endpoint: api/oauth/authorize`
4. `api/auth/callback.ts` sends the `authorization:github:success` postMessage format Decap CMS expects
5. Neither handler file references hardcoded secrets — all values come from `process.env`
</verification>

<success_criteria>
- OAuth authorize endpoint redirects to GitHub login with correct params (client_id, scope, redirect_uri)
- OAuth callback endpoint exchanges code for token using secret from env var and posts result back to Decap CMS window
- Decap CMS config updated to use `name: github` backend with custom auth_endpoint
- Static build (`npm run build`) is unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/04-deployment/04-02-SUMMARY.md`
</output>
